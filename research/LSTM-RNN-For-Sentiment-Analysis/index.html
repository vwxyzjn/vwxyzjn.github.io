<!DOCTYPE html><html data-n-head="" data-n-head-ssr><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" content="width=device-width,initial-scale=1" name="viewport"><meta data-n-head="true" content="Nuxt.js project" name="description" data-hid="description"><title data-n-head="true">Costa Huang | LSTM-RNN For Sentiment Analysis</title><link href="/favicon.ico" rel="icon" data-n-head="true" type="image/x-icon"><link href="/_nuxt/manifest.2382dc7b1165cfa36f92.js" rel="preload" as="script"><link href="/_nuxt/common.3e9129f14dcaeb13d591.js" rel="preload" as="script"><link href="/_nuxt/app.93eaca2919c88cd744d2.js" rel="preload" as="script"><link href="/_nuxt/layouts\default.d623941914e977105d97.js" rel="preload" as="script"><link href="/_nuxt/pages\research\LSTM-RNN-For-Sentiment-Analysis\index.5fcd40c24f7c7ecdc89c.js" rel="preload" as="script"><link href="/_nuxt/pages\research\Furman-Summer-Research-Reflection\index.ebbdc652a9128328c00a.js" rel="prefetch"><link href="/_nuxt/pages\index.353a71a53cace94fa734.js" rel="prefetch"><link href="/_nuxt/pages\research\index.9d3f5e59b795d09ed9ef.js" rel="prefetch"><link href="/_nuxt/pages\research\Aircraft-Shooting-Problem-Dynamic-Programming\index.eb55a5495f0be9f9f85d.js" rel="prefetch"><style data-vue-ssr-id="b2bfc34e:0 961630fe:0 590af1b8:0">.nuxt-progress{position:fixed;top:0;left:0;right:0;height:2px;width:0;-webkit-transition:width .2s,opacity .4s;transition:width .2s,opacity .4s;opacity:1;background-color:#efc14e;z-index:999999}[data-v-71bfcebd]{font-family:Roboto,sans-serif}.fade-enter-active[data-v-71bfcebd],.fade-leave-active[data-v-71bfcebd]{-webkit-transition:opacity .35s;transition:opacity .35s}.fade-enter[data-v-71bfcebd],.fade-leave-to[data-v-71bfcebd]{opacity:0}.sidebar[data-v-71bfcebd]{position:relative;bottom:0;top:0;padding-top:5vh;text-align:center}.sidebar img[data-v-71bfcebd]{width:130px;height:130px}.sidebar h5[data-v-71bfcebd]{font-size:1.05em;color:#53657d}.sidebar .menu-item-wrapper[data-v-71bfcebd]{display:-webkit-box;display:-ms-flexbox;display:flex;width:100%;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-ms-flex-wrap:wrap;flex-wrap:wrap;padding-top:18px}.sidebar .menu-item-wrapper a[data-v-71bfcebd]{padding:10px;color:#9dbf15}.sidebar .menu-item-wrapper .router-link-exact-active[data-v-71bfcebd]{color:#000}.content[data-v-71bfcebd]{padding:40px;position:relative;bottom:0}@media (min-width:768px){.sidebar[data-v-71bfcebd]{height:100vh;padding-top:20vh;position:-webkit-sticky;position:sticky;text-align:right}.sidebar .profile_info[data-v-71bfcebd]{display:inline-block;text-align:center;width:70%}#app[data-v-71bfcebd]{padding-right:calc(100% - 100vw + 17px)}.content[data-v-71bfcebd]{padding-top:60px}}.title[data-v-71bfcebd]{margin-bottom:20px}.section[data-v-71bfcebd]{padding-bottom:30px}.research-article img{max-width:100%}@media (max-width:768px){.research-article h1{font-size:1.5rem}.research-article h2{font-size:1.25rem}.research-article h3,.research-article h4,.research-article h5,.research-article h6{font-size:1rem}.research-article li,.research-article p,.research-article pre{font-size:.85rem}}</style><body data-n-head=""><div id="__nuxt" data-server-rendered="true"><div class="nuxt-progress" style="width:0%;height:2px;background-color:#3b8070;opacity:0"></div><div id="app" data-v-71bfcebd><div class="container-fluid" data-v-71bfcebd><div class="row" data-v-71bfcebd><div class="sidebar col-md-4" data-v-71bfcebd><div class="profile_info" data-v-71bfcebd><img class="profile_picture" data-v-71bfcebd src="/_nuxt/img/profile_picture.3794808.svg"><h1 data-v-71bfcebd>Costa <span data-v-71bfcebd style="font-weight:700">Huang</span></h1><h5 data-v-71bfcebd>strive for interesting things</h5><div class="menu-item-wrapper" data-v-71bfcebd><a href="/" data-v-71bfcebd class="nuxt-link-active">resume</a><a href="/research" data-v-71bfcebd class="nuxt-link-active">research</a><a href="https://drive.google.com/open?id=0B0wkgJhWMQfgazItYXdsWk9ZUkU" data-v-71bfcebd>math</a><a href="https://github.com/vwxyzjn" data-v-71bfcebd>github</a></div></div></div><div class="content col-md-6" data-v-71bfcebd><div class="research-article" data-v-71bfcebd data-v-71bfcebd><div><h1 id="lstm-rnn-for-sentiment-analysis">LSTM-RNN For Sentiment Analysis</h1><p>Author: Trilby Hren and Costa Huang<p>Source code vailable at <a href="https://github.com/costahuang/Sentiment-Analysis-LSTM">https://github.com/costahuang/Sentiment-Analysis-LSTM</a><p><strong>Our project has three main parts:</strong><ol><li>Reproduce and understand Keras(a python machine learning library) official demo code on LSTM-RNN for sentiment analysis<ul><li><a href="https://github.com/fchollet/keras/blob/master/examples/imdb_lstm.py">imdb_lstm.py</a> Main program that rains a LSTM on the IMDB sentiment classification task [1]<li><a href="https://github.com/fchollet/keras/blob/master/keras/datasets/imdb.py">imdb.py</a> Preprocessing script of IMDB movie review dataset [2]</ul><li>Improve the program's accuracy by exploring different techniques:<ul><li>Preprocessing techniques<li>Activation functions<li>Optimizer choices</ul><li>Futher application<ul><li>Visualization of sentiment analysis<li>Applied our result to Amazon Review Datas</ul></ol><h2 id="baseline-algorithm-demo-code-from-keras-">Baseline algorithm (Demo code from Keras)</h2><p>Firstly we execute <a href="https://github.com/fchollet/keras/blob/master/examples/imdb_lstm.py">imdb_lstm.py</a>[1] and yields following results where a test accuracy of 82.35% is acquired.<pre><code class="lang-python">'''Trains a LSTM on the IMDB sentiment classification task.
The dataset is actually too small for LSTM to be of any advantage
compared to simpler, much faster methods such as TF-IDF + LogReg.
Notes:
- RNNs are tricky. Choice of batch size is important,
choice of loss and optimizer is critical, etc.
Some configurations won't converge.
- LSTM loss decrease patterns during training can be quite different
from what you see with CNNs/MLPs/etc.
'''
from __future__ import print_function
import numpy as np
np.random.seed(1337)  # for reproducibility

from keras.preprocessing import sequence
from keras.utils import np_utils
from keras.models import Sequential
from keras.layers import Dense, Dropout, Activation, Embedding
from keras.layers import LSTM, SimpleRNN, GRU
from keras.datasets import imdb

max_features = 20000
maxlen = 80  # cut texts after this number of words (among top max_features most common words)
batch_size = 32

print('Loading data...')
(X_train, y_train), (X_test, y_test) = imdb.load_data(nb_words=max_features)
print(len(X_train), 'train sequences')
print(len(X_test), 'test sequences')

print('Pad sequences (samples x time)')
X_train = sequence.pad_sequences(X_train, maxlen=maxlen)
X_test = sequence.pad_sequences(X_test, maxlen=maxlen)
print('X_train shape:', X_train.shape)
print('X_test shape:', X_test.shape)

print('Build model...')
model = Sequential()
model.add(Embedding(max_features, 128, dropout=0.2))
model.add(LSTM(128, dropout_W=0.2, dropout_U=0.2))  # try using a GRU instead, for fun
model.add(Dense(1))
model.add(Activation('sigmoid'))

# try using different optimizers and different optimizer configs
model.compile(loss='binary_crossentropy',
              optimizer='adam',
              metrics=['accuracy'])

print('Train...')
model.fit(X_train, y_train, batch_size=batch_size, nb_epoch=10,
          validation_data=(X_test, y_test))
score, acc = model.evaluate(X_test, y_test,
                            batch_size=batch_size)
print('Test score:', score)
print('Test accuracy:', acc)
</code></pre><pre><code>Using Theano backend.


Loading data...
25000 train sequences
25000 test sequences
Pad sequences (samples x time)
X_train shape: (25000, 80)
X_test shape: (25000, 80)
Build model...
Train...
Train on 25000 samples, validate on 25000 samples
Epoch 1/10
25000/25000 [==============================] - 138s - loss: 0.5333 - acc: 0.7316 - val_loss: 0.4631 - val_acc: 0.7898
Epoch 2/10
25000/25000 [==============================] - 144s - loss: 0.3812 - acc: 0.8358 - val_loss: 0.3776 - val_acc: 0.8370
Epoch 3/10
25000/25000 [==============================] - 147s - loss: 0.3077 - acc: 0.8737 - val_loss: 0.3687 - val_acc: 0.8360
Epoch 4/10
25000/25000 [==============================] - 146s - loss: 0.2497 - acc: 0.8979 - val_loss: 0.4161 - val_acc: 0.8322
Epoch 5/10
25000/25000 [==============================] - 149s - loss: 0.2100 - acc: 0.9180 - val_loss: 0.4277 - val_acc: 0.8330
Epoch 6/10
25000/25000 [==============================] - 151s - loss: 0.1801 - acc: 0.9298 - val_loss: 0.4318 - val_acc: 0.8362
Epoch 7/10
25000/25000 [==============================] - 148s - loss: 0.1503 - acc: 0.9423 - val_loss: 0.4964 - val_acc: 0.8280
Epoch 8/10
25000/25000 [==============================] - 150s - loss: 0.1328 - acc: 0.9499 - val_loss: 0.5169 - val_acc: 0.8266
Epoch 9/10
25000/25000 [==============================] - 146s - loss: 0.1163 - acc: 0.9548 - val_loss: 0.5354 - val_acc: 0.8227
Epoch 10/10
25000/25000 [==============================] - 153s - loss: 0.1047 - acc: 0.9618 - val_loss: 0.5375 - val_acc: 0.8236
25000/25000 [==============================] - 34s    
Test score: 0.537465095153
Test accuracy: 0.82356
</code></pre><h2 id="understanding-the-source-code">Understanding the source code</h2><p><strong>1. Preprocessing</strong><ul><li>Original Dataset is provided by a <a href="http://ai.stanford.edu/~amaas//data/sentiment/">Stanford research group</a> [3], which provided a set of 25,000 preclassified IMDB movie reviews for training, and 25,000 for testing.<li><a href="https://github.com/fchollet/keras/blob/master/keras/datasets/imdb.py">imdb.py</a>[2] performs the following tasks:<ul><li>Download tokenized the IMDB movie review pre-supplied by Keras, where each review is encoded as word indices. An example training review would look like [3, 213, 43, 324, 12, 4, ...] where 3 represents the third most popular word in the dataset.<li>Shuffle the training and testing dataset.<li>Include only <em>nb_words</em> most frequent word for ouput<li>Add a [1] to each review to mark the start of the sequence<li>Add a [2] to replace the words that are cut off because of <em>nb_words</em><li>Index actual words with <em>"index_from = 3</em>" and higher. (We think this part is <strong>very problematic</strong>, which is mentioned in the next code cell)</ul></ul><pre><code class="lang-python"># From imdb.py, it has a preprocessing code like this, where they use index_from = 3 as the default parameter
# if start_char is not None:
#     X = [[start_char] + [w + index_from for w in x] for x in X]
index_from = 3
example_review = [6, 499, 6, 99, 221, 9, 22, 501, 2, 3]
example_review = [[1] + [w + index_from for w in example_review]]
print(example_review)
</code></pre><pre><code>[[1, 9, 502, 9, 102, 224, 12, 25, 504, 5, 6]]
</code></pre><blockquote><p>As we demoed, this particular parameter "shifted" each word index of the review up by <em>"index_from = 3"</em>, which is totally nonsense in our opinion because it almost changes everything about that review. We also couldn't find any documentation or papers to support such parameter. As a result, in our experiment, we just simply set <em>"index_from = 0"</em>.</blockquote><p><strong>2. Model Building</strong><ul><li><a href="https://github.com/fchollet/keras/blob/master/examples/imdb_lstm.py">imdb_lstm.py</a> builds the model:<ul><li>Limit top most frequent words: Each review only has <em>"max_features = nb_words = 20000"</em> most frequent word index<li>Pad Sequence: Each review is padded with a maximum length of <em>"maxlen = 80"</em><li>Embedding layer: Map each word index into <em>"p = 128"</em> dimentional vector space<ul><li>The original idea came from this landmark paper <a href="http://papers.nips.cc/paper/5021-distributed-representations-of-words-and-phrases-and-their-compositionality.pdf">Distributed Representations of Words and Phrases and their Compositionality</a>[6] where they show a good vector representation for text sequences is achievable.</ul><li>LSTM layer<ul><li>Hochreiter & Schmidhuber [7] first introduced this special kind of RNN to solve the long-term dependency problem. Unlike traditional RNN, LSTM has a memory cell that it uses to determine what information is important by using "forget gate layer" and "input gate layer". [8]</ul><li>Dense(1): fully connect LSTM to create one demensional output<li>Sigmoid<li>Adam optimizer for training.</ul></ul><h2 id="improving-the-algorithm">Improving the algorithm</h2><p><strong><em>Activation functions</em></strong> by <a href="https://keras.io/activations/">Keras.layers.core.Activation</a><ol><li><p>Sigmoid<ol><li>σ(x) = 1/(1+e−x)<li>The sigmoid function is a squashing function. We discovered that this activation function jumps up in test accuracy and converges to about 82.6% after 8 generations.</ol><li><p>ReLU<ol><li>f(x) = max(0,x)<li>For the ReLU activation function our results show dramatic improvement in later generations. It jumps from very low results to much higher accuracy in both testing and training. The final accuracy is not as good as the results from the sigmoid function, it converges to 73.8% in the last generation.</ol><li><p>Tanh<ol><li>tanh(x) = 2σ(2x)−1tanh(x)=2σ(2x)−1<li>The tanh function was slightly better than ReLU with a final accuracy of 77.6%. During our 8 generations, this function seemed to decrease in overall test accuracy perhaps due to overfitting.</ol><li><p>Hard sigmoid<ol><li>The hard sigmoid function performed only slightly better than the sigmoid with a final test accuracy of 83%. From our understanding, it should have converged faster due to increased speed since the precision isn't as important. Perhaps the lower test accuracy is because of the loss in precision rather than the speed.</ol></ol><p>[3] Check out our <a href="https://docs.google.com/document/d/1uQ49jhYYOmwzSPxYYamTXYCq-07Dhhu75eleew3LBPU/edit?usp=sharing">Activation functions data</a><p><strong><em>Optimizer choices</em></strong> by <a href="https://keras.io/optimizers/">keras.optimizers</a><ol><li>SGD (Stochastic Gradient Decent)<ol><li>This type of optimizer uses only a few training examples rather than the entire training set. It also can lead to fast convergence since it doesn't have to run back propagation over the full training set.<li>Sometimes a meaningful order leads to a bias for the gradient and causes poor convergence. Since <code>our data was randomly shuffled before each training</code>, this shouldn't have been an issue.<ol><li><em>Adam</em><ol><li>Adaptive Moment Estimation<li>This optimizer uses momentum and past gradients to help with learning by combining the two advantages of RMSprop and AdaGrad.<li>While we expected this optimizer to perfom the best since it combines the better parts of RMSprop and AdaGrad, it was actually one of our lowest perfoming tests. It showed very slow convergence to 82.6% during our 8 generations. Perhaps it would have converged to a higher accuracy than the others, given a higher number of generations.</ol><li><em>RMSprop</em><ol><li>Root Mean Square Propagation<li>This method adapts the learning rate for each parameter by using tha magnitude of recent gradients to normalize the gradients.<li>From out tests, RSMprop performed the best with a final testing accuracy converging to 84.8%. This optimizer had steady performance through the 8 generations with the lowest accuracy being 82.8%.</ol><li><em>AdaGrad</em><ol><li>Adaptive Gradient Algorithm<li>AdaGrad adapts to the data in order to chose a learning rate for each feature.<li>The performance of the AdaGrad optimizer was mediocre, with a final convergence at 83.4%.</ol><li><em>Nadam</em><ol><li>Nesterov Adaptive Moment Estimation<li>Nadam combines Adam with Nesterov's accelerated gradient.<li>Our results from this test were one of the lowest with Adam, converging to 82.3% and increasing by a whopping 0.3% over the course of 8 generations.</ol></ol></ol></ol><p>[4] Check out our <a href="https://docs.google.com/document/d/1YI5wluhh3rqHs8LBqqL2vOxqNwZdYiPHstWkS2_1s4s/edit?usp=sharing">Optimizer choices data</a><p><strong>Preprocessing techniques</strong><ol><li>Change the padding(<em>"maxlen = 80"</em>) for each reviews<ol><li>It is reasonable to assume when people write reviews, they would express their opinion at the start more often than at the end. So we can limit each review to some <em>"maxlen"</em> to eliminate noisy data.</ol><li>Change the top most frequent words(<em>"max_features = nb_words = 20000"</em>) for training and testing dataset to keep<ol><li>Some words are essential than other words for expressing sentiment. For example, "love" would express more emotion than "keyboard". We therefore limit <em>"max_features"</em> to eliminate less sentimentally expresed words.</ol><li>Set <em>"index_from = 0"</em> as we explained previously</ol><p>Check out our <a href="https://docs.google.com/document/d/1pjZbvzbbHWRUvybd--uTJUhPKvMCjbjxacE3j_zQCM4/edit?usp=sharing">Preprocessing techniques data</a><pre><code class="lang-python">import pandas as pd
import re
import matplotlib.pyplot as plt

""" get data from model generated text; we further used this script to get datas below. """
model_output = "Epoch 1/8 - acc: 0.7090 - val_acc: 0.8205 Epoch 2/8 - acc: 0.8402 - val_acc: 0.8370 , ...."
data_list = re.findall(r'acc: (d+.d+)', model_output)
data_list = list(map(float, data_list))
print(data_list[::2])
print(data_list[1::2])

""" activation function data """
train_hard_sigmoid = pd.DataFrame({'hard_sigmoid': [0.72,0.8137,0.8403,0.8659,0.8892,0.8974,0.9116,0.9184]})
train_sigmoid = pd.DataFrame({'sigmoid': [0.7316,0.8358,0.8737,0.8979,0.9180,0.9298,0.9423,0.9499]})
train_tanh = pd.DataFrame({'tanh': [0.6574,0.7830,0.8335,0.8710,0.8882,0.8954,0.9052,0.8746]})
train_relu = pd.DataFrame({'relu': [0.6524,0.7396,0.7273,0.5278,0.5663,0.6519,0.8128,0.8407]})
activation_train = pd.concat([train_hard_sigmoid,train_sigmoid,train_tanh,train_relu], axis = 1)

test_hard_sigmoid = pd.DataFrame({'hard_sigmoid': [0.7417,0.8195,0.8336,0.8351,0.8280,0.8241,0.8282,0.8302]})
test_sigmoid = pd.DataFrame({'sigmoid': [0.7898,0.8370,0.8360,0.8322,0.8330,0.8362,0.8280,0.8266]})
test_tanh = pd.DataFrame({'tanh': [0.7883,0.7926,0.8153,0.8193,0.7427,0.7679,0.7967,0.7760]})
test_relu = pd.DataFrame({'relu': [0.7634,0.7986,0.5040,0.4519,0.5000,0.7477,0.7482,0.7388]})
activation_test = pd.concat([test_hard_sigmoid,test_sigmoid, test_tanh, test_relu], axis = 1)


""" optimizer data """
train_adam = pd.DataFrame({'adam': [0.7316, 0.8358, 0.8737, 0.8979, 0.918, 0.9298, 0.9423, 0.9499]})
train_RMSprop = pd.DataFrame({'RMSprop': [0.7357, 0.8212, 0.8461, 0.8664, 0.8764, 0.8844, 0.8927, 0.8998]})
train_Adagrad = pd.DataFrame({'Adagrad': [0.7349, 0.8347, 0.8654, 0.8828, 0.8963, 0.902, 0.9118, 0.9164]})
train_Nadam = pd.DataFrame({'Nadam': [0.709, 0.8402, 0.8871, 0.9174, 0.9358, 0.947, 0.957, 0.9625]})
optimizer_train = pd.concat([train_adam,train_RMSprop,train_Adagrad,train_Nadam], axis = 1)


test_adam = pd.DataFrame({'adam': [0.7898, 0.837, 0.836, 0.8322, 0.833, 0.8362, 0.828, 0.8266]})
test_RMSprop = pd.DataFrame({'RMSprop': [0.8288, 0.831, 0.8512, 0.8317, 0.8529, 0.8401, 0.847, 0.849]})
test_Adagrad = pd.DataFrame({'Adagrad': [0.8264, 0.7822, 0.8432, 0.8435, 0.838, 0.8372, 0.8384, 0.835]})
test_Nadam = pd.DataFrame({'Nadam': [0.8205, 0.837, 0.833, 0.8366, 0.8325, 0.8289, 0.8276, 0.8238]})
optimizer_test = pd.concat([test_adam,test_RMSprop,test_Adagrad,test_Nadam], axis = 1)


""" preprocessing data """
train_max_len_120 = pd.DataFrame({'max_len_120': [0.7041, 0.8279, 0.8577, 0.8767, 0.889, 0.8983, 0.9042, 0.9142, 0.9198, 0.9247]})
train_max_len_160 = pd.DataFrame({'max_len_160': [0.722, 0.8315, 0.863, 0.8832, 0.8937, 0.9032, 0.9124, 0.9202, 0.9259, 0.9305]})
train_max_len_200 = pd.DataFrame({'max_len_200': [0.7176, 0.8294, 0.8623, 0.885, 0.8975, 0.9068, 0.9131, 0.9214, 0.9265, 0.9327]})
train_max_len = pd.concat([train_max_len_120,train_max_len_160,train_max_len_200], axis = 1)

test_max_len_120 = pd.DataFrame({'max_len_120': [0.8318, 0.8538, 0.8657, 0.8227, 0.8681, 0.8693, 0.8731, 0.8708, 0.8718, 0.8584]})
test_max_len_160 = pd.DataFrame({'max_len_160': [0.8481, 0.694, 0.8731, 0.8752, 0.8768, 0.8794, 0.8779, 0.88, 0.8834, 0.8792]})
test_max_len_200 = pd.DataFrame({'max_len_200': [0.8254, 0.8498, 0.877, 0.8671, 0.8828, 0.8854, 0.8891, 0.8862, 0.8877, 0.8769]})
test_max_len = pd.concat([test_max_len_120,test_max_len_160,test_max_len_200], axis = 1)

train_max_features_4000 = pd.DataFrame({'max_features_4000': [0.7287, 0.8087, 0.8272, 0.8416, 0.8522, 0.857, 0.8608, 0.8672, 0.8729, 0.8763]})
train_max_features_3000 = pd.DataFrame({'max_features_3000': [0.7218, 0.8039, 0.823, 0.8349, 0.8422, 0.8492, 0.8562, 0.8607, 0.8638, 0.8696]})
train_max_features_2000 = pd.DataFrame({'max_features_2000': [0.7016, 0.7971, 0.8116, 0.8214, 0.8314, 0.8364, 0.8417, 0.8476, 0.8466, 0.8499]})
train_max_features = pd.concat([train_max_features_4000,train_max_features_3000,train_max_features_2000], axis = 1)

test_max_features_4000 = pd.DataFrame({'max_features_4000': [0.7834, 0.821, 0.8296, 0.8473, 0.8521, 0.8435, 0.8461, 0.85, 0.8545, 0.8486]})
test_max_features_3000 = pd.DataFrame({'max_features_3000': [0.7859, 0.824, 0.8231, 0.8448, 0.8465, 0.84, 0.8501, 0.8412, 0.8488, 0.8536]})
test_max_features_2000 = pd.DataFrame({'max_features_2000': [0.8152, 0.8274, 0.83, 0.8392, 0.8268, 0.8376, 0.8452, 0.8457, 0.8424, 0.8413]})
test_max_features = pd.concat([test_max_features_4000,test_max_features_3000,test_max_features_2000], axis = 1)

""" plotting """
%matplotlib inline
f1, (ax1, ax2) = plt.subplots(1, 2, sharey=True)
f1.set_figwidth(15)
activation_train.plot(ax = ax1, title = "activation_train")
activation_test.plot(ax = ax2, title = "activation_test")

f2, (ax3, ax4) = plt.subplots(1, 2, sharey=True)
f2.set_figwidth(15)
optimizer_train.plot(ax = ax3,title = "optimizer_train")
optimizer_test.plot(ax = ax4,title = "optimizer_test")

f3, (ax5, ax6) = plt.subplots(1, 2, sharey=True)
f3.set_figwidth(15)
train_max_len.plot(ax = ax5,title = "train_max_len")
test_max_len.plot(ax = ax6,title = "test_max_len")

f4, (ax7, ax8) = plt.subplots(1, 2, sharey=True)
f4.set_figwidth(15)
train_max_features.plot(ax = ax7,title = "train_max_features")
test_max_features.plot(ax = ax8,title = "test_max_features")
</code></pre><pre><code>[0.709, 0.8402]
[0.8205, 0.837]

&lt;matplotlib.axes._subplots.AxesSubplot at 0x1d192d00f28>
</code></pre><p><img src="/_nuxt/img/output_11_2.0408346.png" alt="png"><p><img src="/_nuxt/img/output_11_3.eda9622.png" alt="png"><p><img src="/_nuxt/img/output_11_4.f5d8933.png" alt="png"><p><img src="/_nuxt/img/output_11_5.827a616.png" alt="png"><h2 id="building-new-model">Building New Model</h2><p>After such comparision, we decided to build model using <em>RMSprop</em> optimizer, <em>sigmoid</em> activation function, <em>max_features</em> = 3000, and <em>max_len</em>= 200.<pre><code class="lang-python">from __future__ import print_function
import numpy as np
np.random.seed(1337)  # for reproducibility

from keras.preprocessing import sequence
from keras.utils import np_utils
from keras.models import Sequential
from keras.layers import Dense, Dropout, Activation, Embedding
from keras.layers import LSTM, SimpleRNN, GRU
from keras.datasets import imdb
from keras.layers.wrappers import TimeDistributed
import pickle
from six.moves import cPickle
import pandas as pd
import math
import matplotlib.pyplot as plt


max_features = 3000
maxlen = 200  # cut texts after this number of words (among top max_features most common words)
batch_size = 32

print('Loading data...')
(XX_train, y_train), (XX_test, y_test) = imdb.load_data(path='imdb_full.pkl', nb_words=max_features, skip_top=10,
              maxlen=None, seed=113,
              start_char=1, oov_char=2, index_from=0)
print(len(XX_train), 'train sequences')
print(len(XX_test), 'test sequences')

print('Pad sequences (samples x time)')
X_train = sequence.pad_sequences(XX_train, maxlen=maxlen)
X_test = sequence.pad_sequences(XX_test, maxlen=maxlen)
print('X_train shape:', X_train.shape)
print('X_test shape:', X_test.shape)

print('Build model...')
model = Sequential()
model.add(Embedding(max_features, 128, dropout=0.2))
model.add(LSTM(128, dropout_W=0.2, dropout_U=0.2))  # try using a GRU instead, for fun
model.add(Dense(1))
model.add(Activation('sigmoid'))

# try using different optimizers and different optimizer configs
model.compile(loss='binary_crossentropy',
              optimizer='rmsprop',
              metrics=['accuracy'])

print('Train...')
model.fit(X_train, y_train, batch_size=batch_size, nb_epoch=10,
          validation_data=(X_test, y_test))
</code></pre><pre><code>Loading data...
25000 train sequences
25000 test sequences
Pad sequences (samples x time)
X_train shape: (25000, 200)
X_test shape: (25000, 200)
Build model...
Train...
Train on 25000 samples, validate on 25000 samples
Epoch 1/10
25000/25000 [==============================] - 288s - loss: 0.5716 - acc: 0.6874 - val_loss: 0.3979 - val_acc: 0.8376
Epoch 2/10
25000/25000 [==============================] - 289s - loss: 0.4373 - acc: 0.8071 - val_loss: 0.3447 - val_acc: 0.8603
Epoch 3/10
25000/25000 [==============================] - 297s - loss: 0.3914 - acc: 0.8336 - val_loss: 0.3410 - val_acc: 0.8577
Epoch 4/10
25000/25000 [==============================] - 301s - loss: 0.3526 - acc: 0.8508 - val_loss: 0.3228 - val_acc: 0.8604
Epoch 5/10
25000/25000 [==============================] - 305s - loss: 0.3224 - acc: 0.8631 - val_loss: 0.2915 - val_acc: 0.8782
Epoch 6/10
25000/25000 [==============================] - 302s - loss: 0.3031 - acc: 0.8756 - val_loss: 0.3119 - val_acc: 0.8671
Epoch 7/10
25000/25000 [==============================] - 305s - loss: 0.2868 - acc: 0.8830 - val_loss: 0.2771 - val_acc: 0.8833
Epoch 8/10
25000/25000 [==============================] - 290s - loss: 0.2745 - acc: 0.8867 - val_loss: 0.2739 - val_acc: 0.8842
Epoch 9/10
25000/25000 [==============================] - 275s - loss: 0.2649 - acc: 0.8904 - val_loss: 0.2715 - val_acc: 0.8844
Epoch 10/10
25000/25000 [==============================] - 284s - loss: 0.2587 - acc: 0.8937 - val_loss: 0.2718 - val_acc: 0.8875





&lt;keras.callbacks.History at 0x1d1950c3588>
</code></pre><p>As we can see, our new model has a better prediction of 88.75% accuracy versus the original model.<h2 id="further-applications">Further Applications</h2><p>Visualization of sentiment analysis ,inspired by <a href="http://euler.stat.yale.edu/~tba3/stat665/lectures/lec21/notebook21.html">Taylor Arnold's jupyter notebook</a> [9]<pre><code class="lang-python">%matplotlib inline
from keras.layers.wrappers import TimeDistributed
import pickle
from six.moves import cPickle
import pandas as pd
import math
import matplotlib.pyplot as plt

def reconstruct_text(index, index_to_word):
    text = []
    for ind in index:
        if ind != 0:
            text += [index_to_word[ind]]
        else:
            text += [""]
    return text

word_to_index = imdb.get_word_index()
index_to_word = {k:v for v,k in word_to_index.items()}
f = open('imdb_full.pkl', 'rb')
(x_train, labels_train), (x_test, labels_test) = cPickle.load(f)
f.close()
df = pd.DataFrame(x_train)

model2 = Sequential()
model2.add(Embedding(max_features, 128, dropout=0.2))
model2.add(LSTM(128, dropout_W=0.2, dropout_U=0.2, return_sequences=True))  # try using a GRU instead, for fun
model2.add(TimeDistributed(Dense(1)))
model2.add(Activation('sigmoid'))
model2.compile(loss='binary_crossentropy',
              optimizer='rmsprop',
              metrics=['accuracy'])

model2.set_weights(model.get_weights())
y_hat2 = model2.predict(X_train)

ind = 100
tokens = reconstruct_text(X_train[ind], index_to_word)

plt.figure(figsize=(16, 10))
plt.plot(y_hat2[ind],alpha=0.5)
for i in range(len(tokens)):
    plt.text(i,0.5,tokens[i],rotation=90)
</code></pre><p><img src="/_nuxt/img/output_16_0.a4a67e4.png" alt="png"><h2 id="apply-current-model-to-amazon-review-data">Apply Current Model to Amazon Review Data</h2><p>Now that we have successfully improved the model, we further apply our new model to Amazon Review data provided by Dr. Allen. Amazon Review Dataset has preclassified sentiment value on 6 categories: books, camera, dvd, health, music, software. We need to complie data in a specific way so that our current model can directly use it.<h3 id="1-change-file-structure">1. Change File Structure</h3><p>We will split the reviews into training set and testing set by changing the file structure<pre><code class="lang-python">from IPython.display import Image
i = Image(filename='file_structure.png')
i
</code></pre><p><img src="/_nuxt/img/output_18_0.1a262f8.png" alt="png"><h3 id="2-preprocess-amazon-reviews">2. Preprocess Amazon Reviews</h3><p><strong>Load reviews:</strong><pre><code class="lang-python">from six.moves import cPickle
import numpy
import os
import pandas as pd
import string
from collections import Counter
from keras.preprocessing.text import Tokenizer

path = ["books/", "camera/", "dvd/", "health/", "music/", "software/"]  # camera, has missing data
ff = []
input_label = []
for i in range(6):
    ff += [path[i] + "train/pos/" + x for x in os.listdir(path[i] + "train/pos")] +          [path[i] + "train/neg/" + x for x in os.listdir(path[i] + "train/neg")] +          [path[i] + "test/pos/" + x for x in os.listdir(path[i] + "test/pos")] +          [path[i] + "test/neg/" + x for x in os.listdir(path[i] + "test/neg")]

    # Because of missing data, we need to measure how many reviews are there in each folder in order to label them correctly.
    train_pos = len(os.listdir(path[i] + "train/pos"))
    train_neg = len(os.listdir(path[i] + "train/neg"))
    test_pos = len(os.listdir(path[i] + "test/pos"))
    test_neg = len(os.listdir(path[i] + "test/neg"))
    input_label += [1] * train_pos + [0] * train_neg + [1] * test_pos + [0] * test_neg


input_text  = []
for f in ff:
    with open(f, 'rb') as fin:
        temp = fin.read().splitlines()
        x = " ".join([x.decode("utf-8", errors = 'ignore') for x in temp])
        input_text += [x]

print(input_text[0])
</code></pre><pre><code>I wish I could give this book four and a half stars instead of four; I can't quite justify five stars in my mind.  Two of the stories were definitely good: the first, "masked Riders" by Parhelion, and the third, "Ricochet" by BA Tortuga.  I enjoyed both, but was not particularly snowed by the intensity of the conflict/plot line or the main characters and their relationships.  Not so the second story: "Hung Up" by Cat Kane was a powerful, intense and moving story about two delightful yet flawed characters who had secrets that tore their relationship up until they were able to work their ways (separately) around the issues.  That story deserved a five stars plus rating and I wish Kane would turn it into a full length novel and develop the characters and their backgrounds more.  This book is an excellent read both for the plot line and the erotic substance.  Enjoy
</code></pre><p><strong>Tokenize reviews:</strong><pre><code class="lang-python">input_text  = []
for f in ff:
    with open(f, 'rb') as fin:
        temp = fin.read().splitlines()
        x = " ".join([x.decode("utf-8", errors = 'ignore') for x in temp])
        input_text += [x]

cut_index = int(len(input_text)/2)
tok = Tokenizer()
tok.fit_on_texts(input_text[:cut_index])

X_train = tok.texts_to_sequences(input_text[:cut_index])
X_test  = tok.texts_to_sequences(input_text[cut_index:])
y_train = input_label[:cut_index]
y_test  = input_label[cut_index:]

print("As you can see, the first review has been encoded as their word index:")
print(X_train[0][:10])
</code></pre><pre><code>As you can see, the first review has been encoded as their word index:
[6, 499, 6, 99, 221, 9, 22, 501, 2, 3]
</code></pre><p><strong>Reconstruct reviews:</strong><pre><code class="lang-python">words = {k:v for v,k in tok.word_index.items()}
def reconstruct_text(index, words):
    text = []
    for ind in index:
        if ind != 0:
            text += [words[ind]]
        else:
            text += [""]
    return text

print(input_text[100])
print(reconstruct_text(X_train[100], words))
</code></pre><pre><code>Peck relates growing up in rural/small town Vermont with a best friend who gets him into lots of trouble. Humor and pranks abound in between lessons learned
['peck', 'relates', 'growing', 'up', 'in', 'rural', 'small', 'town', 'vermont', 'with', 'a', 'best', 'friend', 'who', 'gets', 'him', 'into', 'lots', 'of', 'trouble', 'humor', 'and', 'pranks', 'abound', 'in', 'between', 'lessons', 'learned']
</code></pre><p><strong>Store reviews:</strong><pre><code class="lang-python">f = open('amzn_full.pkl', 'wb')
train_tuple = (X_train, y_train)
test_tuple = (X_test, y_test)
combine = (train_tuple, test_tuple)
cPickle.dump(combine, f)
f.close()
</code></pre><h3 id="3-apply-current-model-to-amazon-reviews-">3. Apply Current Model to Amazon Reviews:</h3><p>Firstly we need to make a copy of <a href="https://github.com/fchollet/keras/blob/master/keras/datasets/imdb.py">imdb.py</a>(the script that loads imdb_full.pkl data) and make it loads our amzn_full.pkl instead. Name the new file amzn.py. Then we apply our model:<pre><code class="lang-python">from __future__ import print_function
import numpy as np
np.random.seed(1337)  # for reproducibility

from keras.preprocessing import sequence
from keras.utils import np_utils
from keras.models import Sequential
from keras.layers import Dense, Dropout, Activation, Embedding
from keras.layers import LSTM, SimpleRNN, GRU
import amzn
from keras.layers.wrappers import TimeDistributed
import pickle
from six.moves import cPickle
import pandas as pd
import math
import matplotlib.pyplot as plt


max_features = 3000
maxlen = 200  # cut texts after this number of words (among top max_features most common words)
batch_size = 32

print('Loading data...')
(XX_train, y_train), (XX_test, y_test) = amzn.load_data(path='amzn_full.pkl', nb_words=max_features)
print(len(XX_train), 'train sequences')
print(len(XX_test), 'test sequences')

print('Pad sequences (samples x time)')
X_train = sequence.pad_sequences(XX_train, maxlen=maxlen)
X_test = sequence.pad_sequences(XX_test, maxlen=maxlen)
print('X_train shape:', X_train.shape)
print('X_test shape:', X_test.shape)

print('Build model...')
model = Sequential()
model.add(Embedding(max_features, 128, dropout=0.2))
model.add(LSTM(128, dropout_W=0.2, dropout_U=0.2))  # try using a GRU instead, for fun
model.add(Dense(1))
model.add(Activation('sigmoid'))

# try using different optimizers and different optimizer configs
model.compile(loss='binary_crossentropy',
              optimizer='RMSprop',
              metrics=['accuracy'])

print('Train...')
model.fit(X_train, y_train, batch_size=batch_size, nb_epoch=10,
          validation_data=(X_test, y_test))
</code></pre><pre><code>Loading data...
5957 train sequences
5957 test sequences
Pad sequences (samples x time)
X_train shape: (5957, 200)
X_test shape: (5957, 200)
Build model...
Train...
Train on 5957 samples, validate on 5957 samples
Epoch 1/10
5957/5957 [==============================] - 63s - loss: 0.6823 - acc: 0.5587 - val_loss: 0.6493 - val_acc: 0.6325
Epoch 2/10
5957/5957 [==============================] - 63s - loss: 0.5696 - acc: 0.7082 - val_loss: 0.5350 - val_acc: 0.7386
Epoch 3/10
5957/5957 [==============================] - 68s - loss: 0.4870 - acc: 0.7692 - val_loss: 0.5081 - val_acc: 0.7480
Epoch 4/10
5957/5957 [==============================] - 70s - loss: 0.4290 - acc: 0.8054 - val_loss: 0.8713 - val_acc: 0.6157
Epoch 5/10
5957/5957 [==============================] - 60s - loss: 0.3910 - acc: 0.8348 - val_loss: 0.5099 - val_acc: 0.7646
Epoch 6/10
5957/5957 [==============================] - 60s - loss: 0.3738 - acc: 0.8385 - val_loss: 0.5034 - val_acc: 0.7702
Epoch 7/10
5957/5957 [==============================] - 59s - loss: 0.3465 - acc: 0.8531 - val_loss: 0.4990 - val_acc: 0.7875
Epoch 8/10
5957/5957 [==============================] - 62s - loss: 0.3143 - acc: 0.8724 - val_loss: 0.5216 - val_acc: 0.7747
Epoch 9/10
5957/5957 [==============================] - 64s - loss: 0.2992 - acc: 0.8795 - val_loss: 0.4989 - val_acc: 0.7900
Epoch 10/10
5957/5957 [==============================] - 64s - loss: 0.2846 - acc: 0.8815 - val_loss: 0.4971 - val_acc: 0.7890





&lt;keras.callbacks.History at 0x1d1f921a668>
</code></pre><h2 id="compare-result-to-original-model">Compare Result to Original Model</h2><pre><code class="lang-python">from __future__ import print_function
import numpy as np
np.random.seed(1337)  # for reproducibility

from keras.preprocessing import sequence
from keras.utils import np_utils
from keras.models import Sequential
from keras.layers import Dense, Dropout, Activation, Embedding
from keras.layers import LSTM, SimpleRNN, GRU
import amzn

max_features = 20000
maxlen = 80  # cut texts after this number of words (among top max_features most common words)
batch_size = 32

print('Loading data...')
(X_train, y_train), (X_test, y_test) = amzn.load_data(path='amzn_full.pkl', nb_words=max_features)
print(len(X_train), 'train sequences')
print(len(X_test), 'test sequences')

print('Pad sequences (samples x time)')
X_train = sequence.pad_sequences(X_train, maxlen=maxlen)
X_test = sequence.pad_sequences(X_test, maxlen=maxlen)
print('X_train shape:', X_train.shape)
print('X_test shape:', X_test.shape)

print('Build model...')
model = Sequential()
model.add(Embedding(max_features, 128, dropout=0.2))
model.add(LSTM(128, dropout_W=0.2, dropout_U=0.2))  # try using a GRU instead, for fun
model.add(Dense(1))
model.add(Activation('sigmoid'))

# try using different optimizers and different optimizer configs
model.compile(loss='binary_crossentropy',
              optimizer='adam',
              metrics=['accuracy'])

print('Train...')
model.fit(X_train, y_train, batch_size=batch_size, nb_epoch=10,
          validation_data=(X_test, y_test))
</code></pre><pre><code>Loading data...
5957 train sequences
5957 test sequences
Pad sequences (samples x time)
X_train shape: (5957, 80)
X_test shape: (5957, 80)
Build model...
Train...
Train on 5957 samples, validate on 5957 samples
Epoch 1/10
5957/5957 [==============================] - 31s - loss: 0.6641 - acc: 0.5949 - val_loss: 0.5708 - val_acc: 0.7077
Epoch 2/10
5957/5957 [==============================] - 31s - loss: 0.4679 - acc: 0.7823 - val_loss: 0.5437 - val_acc: 0.7326
Epoch 3/10
5957/5957 [==============================] - 31s - loss: 0.3293 - acc: 0.8687 - val_loss: 0.5521 - val_acc: 0.7521
Epoch 4/10
5957/5957 [==============================] - 31s - loss: 0.2428 - acc: 0.9077 - val_loss: 0.5821 - val_acc: 0.7601
Epoch 5/10
5957/5957 [==============================] - 31s - loss: 0.1790 - acc: 0.9347 - val_loss: 0.7185 - val_acc: 0.7408
Epoch 6/10
5957/5957 [==============================] - 31s - loss: 0.1270 - acc: 0.9542 - val_loss: 0.7469 - val_acc: 0.7519
Epoch 7/10
5957/5957 [==============================] - 32s - loss: 0.1136 - acc: 0.9599 - val_loss: 0.8070 - val_acc: 0.7430
Epoch 8/10
5957/5957 [==============================] - 31s - loss: 0.0890 - acc: 0.9694 - val_loss: 0.9022 - val_acc: 0.7521
Epoch 9/10
5957/5957 [==============================] - 31s - loss: 0.0721 - acc: 0.9758 - val_loss: 0.9214 - val_acc: 0.7275
Epoch 10/10
5957/5957 [==============================] - 32s - loss: 0.0583 - acc: 0.9802 - val_loss: 0.9235 - val_acc: 0.7334





&lt;keras.callbacks.History at 0x1d20002c588>
</code></pre><pre><code class="lang-python">%%html
&lt;style>
table {float:left}
&lt;/style>
</code></pre><style>table{float:left}</style><h1 id="conclusion">Conclusion</h1><p>Our new model is based on two main hypothesis:<ol><li>It is reasonable to assume when people write reviews, they would express their opinion at the start more often than at the end. So we can limit each review to some <em>"maxlen"</em> to eliminate noisy data.<li>Some words are essential than other words for expressing sentiment. For example, "love" would express more emotion than "keyboard". We therefore limit <em>"max_features"</em> to eliminate less sentimentally expresed words.</ol><p>Therefore by experimenting different <em>"maxlen"</em>, <em>"max_features"</em> , and optimizers, our new model improves the prediction accuracy on both IMDB and Amazon Review dataset, hence validating our hypothesis.<table><thead><tr><th style="text-align:left"><th style="text-align:left">Original Model Provided by Keras<th>Our New Model<tbody><tr><td style="text-align:left"><strong>Amazon Review</strong><td style="text-align:left">73.34%<td>78.90%<tr><td style="text-align:left"><strong>IMDB Movie Review</strong><td style="text-align:left">82.35%<td>88.75%</table><p><br><br><br><h1 id="reference">Reference</h1><p>[1] Fran¸cois Chollet. Keras. <a href="https://github.com/fchollet/keras/blob/master/examples/imdb_lstm.py">imdb_lstm.py</a>, 2015<p>[2] Fran¸cois Chollet. Keras. <a href="https://github.com/fchollet/keras/blob/master/keras/datasets/imdb.py">imdb.py</a>, 2015<p>[3] "Convolutional Neural Networks for Visual Recognition." Web. 06 Dec. 2016. (<a href="http://cs231n.github.io/neural-networks-1">http://cs231n.github.io/neural-networks-1</a>).<p>[4] Ruder, Sebastian. "An Overview of Gradient Descent Optimization Algorithms." 30 Sept. 2016. Web. (<a href="http://sebastianruder.com/optimizing-gradient-descent/">http://sebastianruder.com/optimizing-gradient-descent/</a>).<p>[5] Andrew L. Maas, Raymond E. Daly, Peter T. Pham, Dan Huang, Andrew Y. Ng, and Christopher Potts. <a href="http://ai.stanford.edu/~amaas//papers/wvSent_acl2011.pdf">Learning Word Vectors for Sentiment Analysis</a>. <em>The 49th Annual Meeting of the Association for Computational Linguistics (ACL 2011)</em>, 2011<p>[6] T Mikolov, I Sutskever, K Chen, GS Corrado, J Dean - Advances in neural information processing systems, <a href="http://papers.nips.cc/paper/5021-distributed-representations-of-words-and-phrases-and-their-compositionality.pdf">Distributed Representations of Words and Phrases and their Compositionality</a>, 2013<p>[7] Hochreiter, S., & Schmidhuber, J. <a href="http://deeplearning.cs.cmu.edu/pdfs/Hochreiter97_lstm.pdf">Long short-term memory</a>. Neural computation, 9(8), 1735-1780. 1997<p>[8] Olah C <a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/">Understanding LSTM Networks</a>, 2015<p>[9] Arnold T, <em>STAT 365/665: Data Mining and Machine Learning</em>, <a href="http://euler.stat.yale.edu/~tba3/stat665/lectures/lec21/notebook21.html">Recurrent neural networks</a>, 2016</div></div></div></div></div></div></div><script type="text/javascript">window.__NUXT__={layout:"default",data:[{}],error:null,state:{},serverRendered:!0}</script><script defer src="/_nuxt/manifest.2382dc7b1165cfa36f92.js"></script><script defer src="/_nuxt/layouts\default.d623941914e977105d97.js"></script><script defer src="/_nuxt/pages\research\LSTM-RNN-For-Sentiment-Analysis\index.5fcd40c24f7c7ecdc89c.js"></script><script defer src="/_nuxt/common.3e9129f14dcaeb13d591.js"></script><script defer src="/_nuxt/app.93eaca2919c88cd744d2.js"></script>