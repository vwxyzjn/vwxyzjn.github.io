webpackJsonp([6],{"I2+a":function(n,e,o){"use strict";var t="\n\n# The aircraft Shooting Problem (Dynamic Programming)\nAuthor: Costa Huang\n\n## Introduction\n\nThe nation is at war. The enemy send out a squadron of $n$ aircrafts to attack our troops from various angles. You have a very precise anti-aircraft launcher that will be used to shoot enemy aircrafts. If the launcher is aimed directly at an enemy aircraft, it's guaranteed to destroy the aircraft. Unfortunately, your launcher is ponderous to reposition. Namely, you can only move 1 degree per minute. Then 1 aircraft enter your shoot range per minute. Once they go passed your shoot range, they are gone and you can't shoot them again. You are tasked to destroy the first aircraft, and then destroy as many aircraft as possible. \n\n## Examples\n\nThe aircraft is coming at [50,49,60,48,54,55,56,57,58] angles for each minute. You shoot down the first aircraft at 50 degree and you can either statys at 50 degree, move to 51 degree, or move to 49 degree. The optimal solution would be shooting down 6 aircraft: [50,54,55,56,57,58].\n\n## Analysis\n\nNotice this problem can be solved by brute force method. For each position, we can either statys at $k$ degree, move to $k+1$ degree, or move to $k-1$ degree. So we can just try all possible possibilities and see which possibility shoot the most aircraft. We therefore demonstrate a brute force approach:\n\n\n\n```python\nimport pandas as pd\nimport numpy as np\n    \n# Some testing data\na_1 = [50,49,60,48,54,55,56,57,58]\na_2 = [50,49,60,48,54,55,56,47,46]\na_3 = [50,80,81,82,83]\na_4 = [50,51,49,48]\na_5= [50,51,50,51,50,55,56,57,58,59,60]\na_6 = [50,49,48,50,50,50]\n\n\ndef brute_force(angles, start_angle):\n    \n    if len(angles) == 0:\n        return 0\n    x = brute_force(angles[1:], start_angle+1)\n    y = brute_force(angles[1:], start_angle-1)\n    z = brute_force(angles[1:], start_angle)\n    if angles[0] == start_angle:\n        return max(x + 1, y + 1, z + 1)\n    else:\n        return max(x, y, z)\n    \nprint(brute_force(a_1, a_1[0]))\nprint(brute_force(a_2, a_2[0]))\nprint(brute_force(a_5, a_5[0]))\n```\n\n    6\n    5\n    8\n    \n\nThen we draw the brute force tree for analysis:\n\n\n```python\nfrom IPython.display import Image\nImage(\"pic.JPG\", height = 600, width = 600)\n```\n\n\n\n\n![Responsive image]("+o("Yl6N")+')\n\n\n\nWe somehow spotted this pattern: there are so many interconnected edges, which means we can maybe find a way to efficiently use the past information. For example, if we want to know what\'s the maximum number of aircrafts we can shoot down if we end in 49, there are only two ways to 49: [50,49,49], [50,50,49], but in the process we would have already know which ways shoot down more aircrafts, and we can just take the maximum of them. Therefore we demonstrate the dynamic programming approach:\n\n\n```python\nangles = a_6\nstart_angle = angles[0]\n\ndf = pd.DataFrame(index = angles, columns = range(start_angle - len(angles),start_angle + len(angles)+1), data = 0)\ndef dynamic_programming(df, print_output = False):\n    df.iloc[0][start_angle] = 1\n    columns = list(df.columns)\n    rows = list(df.index)\n    \n    for row in range(0, len(df)-1):\n        # record the degree of the upcoming plane, which is in next row\n        plane_degree = rows[row+1]\n        \n        for col in range(1, len(df.iloc[0])-1):\n            # if the current column has data, the cannon can\n            # go down left, go down, or go down right\n            if df.iloc[row].iloc[col] != 0:\n                data = df.iloc[row].iloc[col]\n                \n                # go down left\n                left_column_degree = columns[col-1]\n                # if our move results in a new destoryed plane: \n                if left_column_degree == plane_degree:\n                    df.iloc[row+1].iloc[col-1] = max(df.iloc[row+1].iloc[col-1], data + 1)\n                else:\n                    df.iloc[row+1].iloc[col-1] = max(df.iloc[row+1].iloc[col-1], data)\n                    \n                # go down\n                down_column_degree = columns[col]\n                # if our move results in a new destoryed plane: \n                if down_column_degree == plane_degree:\n                    df.iloc[row+1].iloc[col] = max(df.iloc[row+1].iloc[col], data + 1)\n                else:\n                    df.iloc[row+1].iloc[col] = max(df.iloc[row+1].iloc[col], data)\n                    \n                # go down right\n                right_column_degree = columns[col+1]\n                # if our move results in a new destoryed plane: \n                if right_column_degree == plane_degree:\n                    df.iloc[row+1].iloc[col+1] = max(df.iloc[row+1].iloc[col+1], data + 1)\n                else:\n                    df.iloc[row+1].iloc[col+1] = max(df.iloc[row+1].iloc[col+1], data)\n        \n        if print_output == True:\n            print(df)\n            print("===============================================================")\n            \n    # now we are ready to trace the planes we shoot down\n    # in the last row search the largest possible planes shoot down in the current row,\n    # namely, max_planes = [planes shoot down, column number]\n    row = len(df)-1 \n    max_planes = [0,0]\n    for col in range(0, len(df.iloc[row])):\n        if df.iloc[row].iloc[col] > max_planes[0]:\n            max_planes[0] = df.iloc[row].iloc[col]\n            max_planes[1] = col\n    \n    \n    # now find the order of planes to shoot down\n    moving_record = [columns[max_planes[1]]]\n    print("now we start to trace back our move")\n    while (row > 0):\n        # from the last row where we hit maximum number of plane, we can go up, go up left, go up right to trace\n        # the record, but we need to go to the maximum of them\n        left_col = max_planes[1]-1\n        right_col = max_planes[1]+2\n        # reset max_planes[planes shoot down] and go up one row\n        max_planes[0] = 0  \n        row -= 1\n        for col in range(left_col, right_col):\n            if df.iloc[row].iloc[col] > max_planes[0]:\n                max_planes[0] = df.iloc[row].iloc[col]\n                max_planes[1] = col\n        \n        moving_record += [columns[max_planes[1]]]\n        \n        print(moving_record)\n    \n    moving_record.reverse()\n    print("after reversing, now the moving record is:")\n    print(moving_record)\n    \n    \n    # Lastly, we ouput the specific planes we choose to shoot\n    planes_chosen = []\n    for i in range(0, len(df.index)):\n        if df.index[i] == moving_record[i]:\n            planes_chosen += [df.index[i]]\n    \n    print("lastly, we print out planes chosen to shoot down")\n    print(planes_chosen)\n    \n    return max(df.iloc[-1])\n    \n\n\ndp_output = dynamic_programming(df, print_output = True)\nprint("input data is ", angles)\nprint("dynamic programming can shoot down", dp_output, "planes")\nprint("brute force method can shoot down", brute_force(angles, start_angle), "planes")\n```\n\n        44  45  46  47  48  49  50  51  52  53  54  55  56\n    50   0   0   0   0   0   0   1   0   0   0   0   0   0\n    49   0   0   0   0   0   2   1   1   0   0   0   0   0\n    48   0   0   0   0   0   0   0   0   0   0   0   0   0\n    50   0   0   0   0   0   0   0   0   0   0   0   0   0\n    50   0   0   0   0   0   0   0   0   0   0   0   0   0\n    50   0   0   0   0   0   0   0   0   0   0   0   0   0\n    ===============================================================\n        44  45  46  47  48  49  50  51  52  53  54  55  56\n    50   0   0   0   0   0   0   1   0   0   0   0   0   0\n    49   0   0   0   0   0   2   1   1   0   0   0   0   0\n    48   0   0   0   0   3   2   2   1   1   0   0   0   0\n    50   0   0   0   0   0   0   0   0   0   0   0   0   0\n    50   0   0   0   0   0   0   0   0   0   0   0   0   0\n    50   0   0   0   0   0   0   0   0   0   0   0   0   0\n    ===============================================================\n        44  45  46  47  48  49  50  51  52  53  54  55  56\n    50   0   0   0   0   0   0   1   0   0   0   0   0   0\n    49   0   0   0   0   0   2   1   1   0   0   0   0   0\n    48   0   0   0   0   3   2   2   1   1   0   0   0   0\n    50   0   0   0   3   3   3   3   2   1   1   0   0   0\n    50   0   0   0   0   0   0   0   0   0   0   0   0   0\n    50   0   0   0   0   0   0   0   0   0   0   0   0   0\n    ===============================================================\n        44  45  46  47  48  49  50  51  52  53  54  55  56\n    50   0   0   0   0   0   0   1   0   0   0   0   0   0\n    49   0   0   0   0   0   2   1   1   0   0   0   0   0\n    48   0   0   0   0   3   2   2   1   1   0   0   0   0\n    50   0   0   0   3   3   3   3   2   1   1   0   0   0\n    50   0   0   3   3   3   3   4   3   2   1   1   0   0\n    50   0   0   0   0   0   0   0   0   0   0   0   0   0\n    ===============================================================\n        44  45  46  47  48  49  50  51  52  53  54  55  56\n    50   0   0   0   0   0   0   1   0   0   0   0   0   0\n    49   0   0   0   0   0   2   1   1   0   0   0   0   0\n    48   0   0   0   0   3   2   2   1   1   0   0   0   0\n    50   0   0   0   3   3   3   3   2   1   1   0   0   0\n    50   0   0   3   3   3   3   4   3   2   1   1   0   0\n    50   0   3   3   3   3   4   5   4   3   2   1   1   0\n    ===============================================================\n    now we start to trace back our move\n    [50, 50]\n    [50, 50, 49]\n    [50, 50, 49, 48]\n    [50, 50, 49, 48, 49]\n    [50, 50, 49, 48, 49, 50]\n    \n    after reversing, now the moving record is:\n    [50, 49, 48, 49, 50, 50]\n    \n    lastly, we print out planes chosen to shoot down\n    [50, 49, 48, 50, 50]\n    \n    input data is  [50, 49, 48, 50, 50, 50]\n    dynamic programming can shoot down 5 planes\n    brute force method can shoot down 5 planes\n    \n\nNow we can test different data by generating some random list and run the program to see when does brute force become really slow.\n\n\n```python\nt = np.random.choice(10, 14) + 50\nt\n# (2, 5) + 10 would out put size 5, origin 10, random integer from (10-2, 10+2) \n# at size 14 is where you can see brute force takes more than an instant\n# notice 3^14 = 4782969\n```\n\n\n\n\n    array([59, 53, 50, 50, 54, 56, 50, 58, 53, 57, 54, 58, 52, 53])\n\n\n\n\n```python\nangles = t\nstart_angle = angles[0]\ndf = pd.DataFrame(index = angles, columns = range(start_angle - len(angles),start_angle + len(angles)+1), data = 0)\ndp_ouput = dynamic_programming(df)\nprint("\ninput data is ", angles)\nprint("dynamic programming can shoot down", dp_ouput, "planes")\nprint("brute force method can shoot down", brute_force(angles, start_angle), "planes")\n```\n\n    now we start to trace back our move\n    [53, 52]\n    [53, 52, 53]\n    [53, 52, 53, 54]\n    [53, 52, 53, 54, 53]\n    [53, 52, 53, 54, 53, 53]\n    [53, 52, 53, 54, 53, 53, 54]\n    [53, 52, 53, 54, 53, 53, 54, 55]\n    [53, 52, 53, 54, 53, 53, 54, 55, 56]\n    [53, 52, 53, 54, 53, 53, 54, 55, 56, 55]\n    [53, 52, 53, 54, 53, 53, 54, 55, 56, 55, 56]\n    [53, 52, 53, 54, 53, 53, 54, 55, 56, 55, 56, 57]\n    [53, 52, 53, 54, 53, 53, 54, 55, 56, 55, 56, 57, 58]\n    [53, 52, 53, 54, 53, 53, 54, 55, 56, 55, 56, 57, 58, 59]\n    \n    after reversing, now the moving record is:\n    [59, 58, 57, 56, 55, 56, 55, 54, 53, 53, 54, 53, 52, 53]\n    \n    lastly, we print out planes chosen to shoot down\n    [59, 56, 53, 54, 52, 53]\n    \n    input data is  [59 53 50 50 54 56 50 58 53 57 54 58 52 53]\n    dynamic programming can shoot down 6 planes\n    brute force method can shoot down 6 planes\n';e.a={data:function(){return{articleStr:t}},head:function(){return{title:"Costa Huang | The aircraft Shooting Problem (Dynamic Programming)"}}}},QFFt:function(n,e,o){"use strict";var t=function(){var n=this,e=n.$createElement;return(n._self._c||e)("article-view",{attrs:{article:n.articleStr}})},a=[],r={render:t,staticRenderFns:a};e.a=r},WpdZ:function(n,e,o){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var t=o("I2+a"),a=o("QFFt"),r=o("VU/8"),i=r(t.a,a.a,!1,null,null,null);e.default=i.exports},Yl6N:function(n,e,o){n.exports=o.p+"img/output_3_0.9db7dc7.jpeg"}});
//# sourceMappingURL=index.c23398a85dd04a5e6ce1.js.map